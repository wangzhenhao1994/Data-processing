%--------------------------------------------------------------------------
% 
% Read tablulated values of a function from formatted data file and
% perform (one-, two-, three-, or multi-dimensional) interpolation using 
% MATLAB's builtin interp1, interp2, interp3, interpn functions which  
% allow nearest neighbor, linear, cubic, spline interpolation, etc
%
% For multi-dimensional tables, the number of grid points along
% each dimension has to be specified in order to reshape the 
% data from the input file accordingly.
%
% The data points in the files are assumed to be tabulated on uniform
% grids such as generated by Matlab's builtin meshgrid or ndgrid commands.
% Each line needs to contain the following input data
% Pairs      : x,       f(x)     for 1-dimensional tables
% Triples    : x, y,    f(x,y)   for 2-dimensional tables
% Quadruples : x, y, z, f(x,y,z) for 3-dimensional tables
% etc ...
%
% Important: The values must be ordered such that the first 
% coordinate varies the fastest, then the second and so forth.
%
% Empty lines in input data file are (hopefully!) ignored
% Data files can contain comments that start with a percentage sign; 
% MATLAB ignores those when reading the file.
%
%--------------------------------------------------------------------------

% This file is part of the WavePacket program package for quantum-mechanical
% simulations, and subject to the GNU General Public license v. 2 or later.
%
% Copyright (C) 2004-2017 Burkhard Schmidt's group
%               2008 Ulf Lorenz
%
% see the README file for license details.

function fi = interp (ri, filename, n_pts, method, r_conv, f_conv)

% Load data from input file
data = load (filename);
prt.disp(['Loading tabulated data from file : ' filename])

% Get number of data points
n_dat = size(data,1);   % Number of rows
n_dim = size(data,2)-1; % Number of columns, reduced by one
prt.disp(['Number of data points found      : ' int2str(n_dat)])
prt.disp(['Number of dimensions detected    : ' int2str(n_dim)])
            
% Check for consistency (for n_dim>1 only)
if n_dim>1
    if n_dat ~= prod(n_pts)
        prt.error ('Inconsistent number of data points')
    end
end

% Extract components of R; reshape (for n_dim>1); convert units
r = cell(n_dim,1);
for k=1:n_dim
    r{k} = data(:,k);    % k-th column: R_k
    if n_dim>1
        r{k} = reshape( r{k}, n_pts );
    end
    r{k} = r{k} / r_conv;
end

% Extract f(R); find min/max; reshape (for n_dim>1); convert units
f = data(:,n_dim+1);    % last column: V(R)
if n_dim>1
    f = reshape( f, n_pts );
end
f = f / f_conv;
[c,s] = min ( f(:) );
[d,t] = max ( f(:) );
    
% Test for 3D case
% figure(5)
% slice (r{2},r{1},r{3},f,0,0,0); colorbar
% xlabel('Y-axis')
% ylabel('X-axis')
% zlabel('Z-axis')
% title('Raw data')

n = n_dat;
switch n_dim
    case 1
        prt.disp(['First data pair      : ' num2str(r{1}(1)) ' / ' num2str(f(1),8)])
        prt.disp(['Last data pair       : ' num2str(r{1}(n)) ' / ' num2str(f(n),8)])
        prt.disp(['Minimum              : ' num2str(r{1}(s)) ' / ' num2str( c  ,8)])
        prt.disp(['Maximum              : ' num2str(r{1}(t)) ' / ' num2str( d  ,8)])
        fi = interp1( r{1}, f, ri{1}, method, 'extrap' );
        
    case 2
        prt.disp(['First data triple    : ' num2str(r{1}(1)) ' / ' num2str(r{2}(1)) ' / ' num2str(f(1),8)])
        prt.disp(['Last data triple     : ' num2str(r{1}(n)) ' / ' num2str(r{2}(n)) ' / ' num2str(f(n),8)])
        prt.disp(['Minimum              : ' num2str(r{1}(s)) ' / ' num2str(r{2}(s)) ' / ' num2str( c  ,8)])
        prt.disp(['Maximum              : ' num2str(r{1}(t)) ' / ' num2str(r{2}(t)) ' / ' num2str( d  ,8)])
        % Note that interp2/3 require the tabulated x,y values
        % to have the same format ("plaid") as if they were
        % produced by MESHGRID. However, we have used NDGRID
        % to create the multi-dimensional array.
        % These two functions are essentially identical
        % except for the order of the first two input arguments
        % which are switched. This has to be compensated here!
        fi = interp2( r{2}, r{1}, f, ri{2}, ri{1}, method );
        
    case 3
        prt.disp(['First data quadruple : ' num2str(r{1}(1)) ' / ' num2str(r{2}(1)) ' / ' num2str(r{3}(1)) ' / ' num2str(f(1),8)])
        prt.disp(['Last data quadruple  : ' num2str(r{1}(n)) ' / ' num2str(r{2}(n)) ' / ' num2str(r{3}(n)) ' / ' num2str(f(n),8)])
        prt.disp(['Minimum              : ' num2str(r{1}(s)) ' / ' num2str(r{2}(s)) ' / ' num2str(r{3}(s)) ' / ' num2str( c  ,8)])
        prt.disp(['Maximum              : ' num2str(r{1}(t)) ' / ' num2str(r{2}(t)) ' / ' num2str(r{3}(t)) ' / ' num2str( d  ,8)])
        % Swapping the first two arguments, see above
        fi = interp3( r{2}, r{1}, r{3}, f, ri{2}, ri{1}, ri{3}, method );
                
    otherwise
        prt.disp(['Minimum              : ' num2str(c,8)])
        prt.disp(['Maximum              : ' num2str(d,8)])
        % Note that interpn requires the tabulated values
        % to have the same format ("plaid") as if they were
        % produced by NDGRID. Hence, there is no need to
        % swap the first two arguments here!
        fi = interpn( r{1:n_dim}, f, ri{1:n_dim}, method );
end
prt.disp (' ')

% Test for 3D case
% figure(6)
% slice (ri{2},ri{1},ri{3},fi,0,0,0); colorbar
% xlabel('Y-axis')
% ylabel('X-axis')
% zlabel('Z-axis')
% title('Interpolated')



